---
layout: default
title: carrier98
---

# carrier98

**Data modulation for a new era.**

carrier98 is an LLM-to-LLM wire protocol for structured data. It modulates serialized machine state into a parser-inert, copy-paste safe visual stream.

---

## Demo

**What the LLM receives:**

```
ğ“¹â”—â—…â•—â–šâ–¼â•¦â•‹â—‰â—Šâ•§â–šâ”â•–â–¬â”»â–»â•¹â•£â•›â—â—Ÿâ–¬â–¦â•«â•¬â– â–—â”“â•¡â—ºâ—€â—”â•˜â—â”«â—â––â•’â–¦â—¥â–¥â•“â”£â•¨â—‰â•¡â– â—¿â–§â—â–—â”—â—”â–šâ–®â•¢â”»â”ƒâ•“â•—â”â–œâ•Ÿâ—ºâ•˜â–›â– â•“â—¤â•¸â—¥â•§â”ƒâ•¤â•¸â–›â•¡â–»â–¦â•˜â•˜â–¦â—•â•™â•¢â••â—¯â—œâ•ªâ”«â—€â––â”›â•¢â••â•“â—â–ºâ”£â—ºâ–¼â•â”³â—â”—â••â—¢â•˜â•Ÿâ”ƒâ”«â–§â—˜â”»â•ªâ•¡â–§â–—â• â–¨â–¤â–¶â•«â–»â•™â–œâ–ˆâ–—â”ƒâ”â–˜â—â–¼â•›â”«â—¤â–¦â•â—£â—Ÿâ—Ÿâ•˜â–—â–›â••â—¤â•â”â•â•»â•¥â–¤â•”â•¨â•Ÿâ–®â–°â•šâ•¢â•â•¬â•œâ•¨â”³â”“â”³â–®â”“â—â—â—¢â–¨â•â•»â–˜â•«â—¯â•™â–§â•—â–²â—¿â•«â–™â– â•¸â•—â—…â–ˆâ•˜â—¸â••â—€â•˜â—â—â—â•§â– â—…â—â–—â—‰â–²â•ºâ–¬â–›â—¢â”—â—¯â•¡â–¶â•¤â•¤â•â•â–¤â—‰â–˜â•‘â—…â– â—¤â–»â•£â–°â••â•ºâ—â•‘â•»â”â”›â•¢â–®â•¹â”»â–ˆâ—¥â–¦â”â—¹â•¤â—Šâ•¡â—¢â–®â•¬â•¢â•šâ—¯â–â–œâ—ºâ•‹â– â–¤â–˜â–¼â—¥â–ºâ—â”—â•Ÿâ”â•”â–ˆâ• â—â–šâ•¥â•“â–¶â–¥â•–â••â–®â—â—£â—€â–°â•šâ–©â”ƒâ–™â—¿â—œâ—¢â–¥â—‰â—†â—œâ–Ÿâ•â—„â”›â•“â—¸â–˜â–¼â—¢â–¦â•œâ•˜â—â•¥â•—â”»â—†â”»â•“â•¥â—â–›â•ªâ–®â—£â–—â—‰â—¢â•—â—¤â–°â•–â•‹â—€â—¤â—†â–¥â•’â”«â•§â•‹â•â––â•¥â•ºâ—â•â—â–¼â•¡â”³â•ºâ”—â—Ÿâ•—â–»â—¸â–˜â•â•‹â•¬â•»â•§â•£â•â—•â–»â—£â–¦â•©â•¸â–˜â–®â—¤â–¤â–—â—…â—¢â•»â•â”»â•¤â•Ÿâ–¥â–šâ•¸â•’â–¨â—Šâ—ºâ—â–»â•¹â•¡â–™â•©â•“â”â—â•¢â–ºâ—â–²â—€â––â–¼â–¥â—Ÿâ”â—”â–¨â•™â—¢â—”â—¼â•§â—„â”â•–â—¹â–¨â–¼â•£â•˜â—£â”›â•»â––â–™â”›â––â• â•—â•¹â•šâ—œâ–¬â–²â•™â•ªâ—”â–ºâ•¤â•«â•›â•”â•â—•â•˜â—â–œâ•¤â• â—¤â• â•¤â–°â•«â• â•“â”³â– â”³â”«â–™â–©â–¼â—¤â•–â—¿â•«â—„â—¤â—¢â–™â—€â•”â•ªâ—ºâ––â•â”“â•¥â—„â–—â—â—â–¬â–®â”›â–™â•™â–¶â–¨â––â•“â—¯â—â”›â–©â•”â–â••â•»â—¯â•œâ”³â”£â•”â–°â—ºâ—„â•œâ–®â• â—â–¥â•§â–â—†â”ƒâ•”â—†â—â•šâ•¢â—˜â—‰â–¥â•œâ–¤â–ˆâ–²â—Ÿâ–ºâ–¶â•â–â”«â—¼â”»â•™â•œâ–§â•¡â”—â–°â—…â–»â—â•–â• â—¹â••â—†â–¦â–˜â—œâ—¯â”â–™â• â–¶â”â–§â•¡â—„â—•â”â—¤â•â–›â—â–¶â—„â–¬â–œâ”»â”£â”«â–â–ˆâ—¯â—•â—¢â—€â•¤â• â—¥â•œâ–§â—„â—¤â•‹â”ƒâ–©â—Šâ–â–¼â– â—”â•ºâ–šâ—Ÿâ–ºâ—â•¬â—¯â—â–šâ• â–®â”â”£â–›â–¦â•¡â—¤â– â•šâ—¤â–ºâ–™â”“â– â”—â–ˆâ•¤â—œâ•¥â•¤â•’â—¥â–â•’â••â—£â”â•«â–»â—”â•¢â–˜â—¹â—â–›â•¹â•ºâ”³â•¸â•–â•¹â”â—„â•ªâ•§â”â•Ÿâ–ºâ•›â–°â–â–©â•ºâ–Ÿâ–™â–¼â–™â–™â•šâ—‰â—¼â•‹â”»â—•â•‹â—â•¸â•â–§â–¥â•©â—”â”£â–â–¤â–¥â–Ÿâ•¹â—¤â—†â•—â–®â—€â—â•œâ–¦â–ˆâ•©â•¤â•‘â•¸â•˜â•â–šâ•«â•â• â—¢â–¦â”£â—”â••â•»â•˜â•—â–â–²â•¢â—¿â•â–Ÿâ–§â”â”â–¤â—â•ºâ–¦â—¤â–Ÿâ–®â–Ÿâ”—â•›â–¶â–°â–°â”—â•¸â—Šâ–©â–šâ•»â–¬â–—â–°â–šâ•¥â—â––â•›â•»â–Ÿâ”›â•˜â—¼â•”â•»â–˜â•“â•¤â•Ÿâ•˜â—Ÿâ•ªâ•â–œâ–¼â•šâ–—â–™â–â–²â•¢â—¥â—â–˜â–¨â–ˆâ—¤â—„â—¢â”«â–¼â—ºâ—¤â—•â—¼â—¢â•‘â—¿â•¨â”£â—â–¦â–°â•©â•’â–¼â—â•‹â”â•â—â—¥â–¨â—¼â•â•¤â•¥â•¦â•–â–¼â•¸â•Ÿâ—¹â–šâ•¨â—„â”£â–Ÿâ–¬â—•â—‰â•â•©â•œâ•‹â–¦â•¬â•¬â•”â•™â”—â•–â—¿â•â—‰â—â– â—ºâ”ƒâ•â•¢â–—â—„â•–â––â—œâ—¹â—„â–œâ••â”“â–¶â–§â–¥â—â–®â–â—¢â–â—¤â•œâ•Ÿâ–â–¼â–›â”ƒâ”³â•¡â–™â—â–Ÿâ–â—¢â—â–šâ•¤â•ºâ—¤â–Ÿâ•ºâ—€â—â—…â• â•˜â•«â•›â—Šâ—â•˜â—£â—˜â—â–ˆâ”³â•â•¨â•¸â—¯â”«â•¡â—â–—â•¹â•©â•ªâ–§â–˜â”»â•¢â–°â•â•¹â–šâ•—â•ªâ”›â––â•¥â—â–˜â•¸â—¸â• â–ˆâ–²â•¤â•–â•“â—¥â–¬â”â—¸â•¥â•’â–¤â•Ÿâ–¦â•“â•§â–Ÿâ—Šâ—¤â–¶â•›â•¬â—œâ—¯â—Šâ—¯â–¶â•¦â—œâ”³â•¤â–˜â•â–˜â–—â—œâ–¥â”â–â•£â–§â•¥â•ºâ–â”â—Ÿâ–¶â—”â–â”»â•˜â—‰â–¥â•¦â—â—˜â•£â–»â–ºâ—”â•—â•›â—¼â”³â”£â– â•“â—£â•â•â—£â—â”³â–¥â•§â–›â•¦â–â–®â—ºâ•£â—â—¢â–ºâ•â”â–›â—â–¥â—ºâ—â•’â•¥â—¥â– â”›â—‰â–—â—¤â—¿â–¼â••â—‰â–œâ—”â–¦â•â•§â—†â•˜â•¹â•ªâ•’â•‹â–°â—â•Ÿâ–Ÿâ•ªâ–™â—•â•¥â–šâ•™â–¼â—¯â—£â–¨â”£â•“â”«â–¶â–›â—¯â—¤â”«â—œâ–šâ—£â”ƒâ”ƒâ—¹â”»â—â”£â– â–¦â–™â•œâ—†â•¬â”«â—â–®â–¦â—â”³â—£â–Ÿâ—€â–¼â•¢â—¿â—„â”›â•’â•‘â•–â—•â•â–¬â—œâ•œâ•«â•«â–§â—…â–®â—£â–Ÿâ•¬â– â–Ÿâ—â–—â•â”«â–¬â–ºâ–œâ–™â”ƒâ•â—â”â–¬â—¯â”»â—¤â—¢â•¨â•Ÿâ–œâ•šâ•¤â—â•¦â•â•”â–—â–â—Šâ—˜â—•â–¦â••â”â•›â–¬â”â•â•›â–ºâ—†â•™â—¢â•˜â”£â•˜â—ºâ–šâ—¢â–¤â—£â”³â”—â•â—â•¨â•«â•œâ”«â•¢â–ˆâ•šâ”³â—ºâ”ƒâ”»â•ºâ•šâ–§â–²â—¤â—€â—â”«â•â•â•¡â—â—Šâ–â•¸â—”â—â”£â—”â—â•¡â—â–â•ºâ—‰â•»â– â•“â”³â–œâ—”â•§â–¬â—”â—¤â—¸â•©â–°â•ºâ—¿â—¢â—¸â–¤â”â—œâ”³â•™â•â•»ğ“º
```

**1,221 characters.** Parser-inert. Copy-paste safe.

**What the human sees** (after decode):

```json
{"quotes":[
  {"character":"Morpheus","quote":"I'm trying to free your mind, Neo. But I can only show you the door. You're the one that has to walk through it."},
  {"character":"Trinity","quote":"The answer is out there, Neo. It's looking for you, and it will find you if you want it to."},
  {"character":"Oracle","quote":"You didn't come here to make the choice. You've already made it. You're here to try to understand why you made it."},
  {"character":"Smith","quote":"Never send a human to do a machine's job."},
  {"character":"Keymaker","quote":"There is a building. Inside this building there is a level where no elevator can go, and no stair can reach."},
  ...
]}
```

**2,666 characters.** 54% larger. All those braces, quotes, and colons - syntax the LLM has to parse.

The carrier stays the same. The human gets JSON. Everyone wins.

**Jump to:** [Philosophy](#philosophy) Â· [Wire Format](#wire-format) Â· [Alphabet](#alphabet) Â· [Binary Format](#binary-format) Â· [Benchmarks](#benchmarks) Â· [Implementations](#implementations) Â· [**fiche** â†’](fiche)

---

## Philosophy

The carrier wave carries the signal. Like DTMF tones encoding digits for telephone switches, carrier98 encodes structured data for LLM pipelines. It's data modulation - not different from hitting 0-9 on a phone keypad, just highly advanced.

**Design principles:**

1. **Parser-inert** - No regex, JSON parser, shell, or syntax highlighter will grab it by accident
2. **Display-safe** - Renders visibly on any terminal, editor, or browser (no invisible chars, no replacement boxes)
3. **Copy-paste debuggable** - See it in a log, copy it, decode it
4. **Self-describing** - Schema embedded in the payload
5. **Dense** - Smaller than JSON, smaller than TOON

> *"The image translators work for the construct program - but there's way too much information to decode the Matrix. I don't even see the code. All I see is blonde, brunette, redhead."*

---

## The Name

**98** = 96 alphabet characters + 2 frame delimiters

Also a nod to Windows 98 - a time when machines were learning to communicate with each other.

---

## Wire Format

```
ğ“¹{payload}ğ“º
```

| Component | Value | Description |
|-----------|-------|-------------|
| Frame start | `ğ“¹` (U+13379) | Egyptian hieroglyph, opening quotation mark |
| Frame end | `ğ“º` (U+1337A) | Egyptian hieroglyph, closing quotation mark |
| Payload | Base-96 encoded | Binary data in carrier98 alphabet |

### Why Hieroglyphs?

These aren't arbitrary ancient characters - they're actual quotation marks from 5,000 years ago. Rope coils the Egyptians used to frame quoted text. Perfect semantic match for framing protocol data.

- **Stable**: Unicode 5.2 (2009), 15+ years proven
- **Parser-inert**: No parser on Earth looks for hieroglyphs
- **Visually distinct**: You see them, you know it's carrier98

---

## Alphabet

96 visually-safe Unicode characters:

| Range | Block | Count | Examples |
|-------|-------|-------|----------|
| U+2501â€“U+257B | Box Drawing (heavy/double) | 44 | `â”` `â”ƒ` `â”` `â•”` `â•‘` |
| U+2588â€“U+259F | Block Elements | 11 | `â–ˆ` `â–€` `â–„` `â–Œ` `â–` |
| U+25A0â€“U+25FF | Geometric Shapes (solid) | 41 | `â– ` `â–²` `â—` `â—†` `â—‰` |

**Properties:**
- Visually distinct (no confusables like 0/O or 1/l)
- Cross-platform safe (renders on Windows, macOS, Linux)
- No blanks (nothing looks like whitespace)
- Size-independent (readable at any font size)
- Monospace-friendly (consistent width in terminals)

**Excluded:**
- ASCII (parser-visible)
- Light box drawing (invisible at small sizes)
- Outline shapes (look empty)
- Emoji (inconsistent rendering)
- CJK (width issues)
- C0/C1 control characters
- Private use areas

---

## Binary Format

```
[compression][header][values]
```

### Compression Prefix (1 byte)

| Byte | Algorithm |
|------|----------|
| 0x00 | None |
| 0x01 | Brotli |
| 0x02 | LZ4 |
| 0x03 | Zstd |

### Header

```
[flags: u8]
[root_key?: varint string]    // if FLAG_HAS_ROOT_KEY
[row_count: varint]
[field_count: varint]
[field_types: nibble-packed]
[field_names: varint strings]
[null_bitmap?: bytes]         // if FLAG_HAS_NULLS
```

**Flags:**

| Bit | Flag | Description |
|-----|------|-------------|
| 0 | TYPED_VALUES | Per-value type tags (reserved) |
| 1 | HAS_NULLS | Null bitmap present |
| 2 | HAS_ROOT_KEY | Root key in header |

**Field types (4-bit tags):**

| Tag | Type | Encoding |
|-----|------|----------|
| 0 | U64 | Varint |
| 1 | I64 | Zigzag varint |
| 2 | F64 | 8 bytes IEEE 754 |
| 3 | String | Varint length + UTF-8 |
| 4 | Bool | Packed bits |
| 5 | Null | No bytes (bitmap only) |
| 6 | Array | Varint count + elements |
| 7 | Any | Type tag + value (reserved) |

### Values

Row-major order. No delimiters between values - the schema defines boundaries.

- **Integers:** LEB128 varint (MSB continuation bit)
- **Signed integers:** Zigzag encoding, then varint
- **Floats:** 8 bytes, IEEE 754 double, little-endian
- **Strings:** Varint length + UTF-8 bytes
- **Arrays:** Varint count + elements
- **Nulls:** No bytes (tracked in bitmap)

---

## Encoding Pipeline

```
Structured Data â†’ IR â†’ Binary â†’ Compress â†’ Base96 â†’ Frame
```

**Intermediate Representation (IR)** is the pivot point. Parsers (JSON, YAML, CSV) produce IR. The binary packer consumes IR. This decouples input formats from the wire format.

---

## Example

**Input:**
```json
{"users":[{"id":1,"name":"alice"},{"id":2,"name":"bob"}]}
```

**Binary structure:**
```
Flags: 0x04 (HAS_ROOT_KEY)
Root key: "users"
Row count: 2
Field count: 2
Field types: [U64, String]
Field names: ["id", "name"]
Values: 1, "alice", 2, "bob"
```

**Wire format:**
```
ğ“¹â•£â—Ÿâ•¥â—•â—â–°â—£â—¥â–Ÿâ•ºâ––â—˜â–°â—â–¤â—€â•§ğ“º
```

---

## Benchmarks

**What the LLM sees** (characters in context window):

| Payload | JSON | carrier98+brotli | Context Reduction |
|---------|------|------------------|-------------------|
| 1 KB | 1,055 | 403 | 62% smaller |
| 10 KB | 14,080 | 1,075 | 92% smaller |
| 100 KB | 245,081 | 7,885 | **97% smaller** |

At 100KB, you're packing 245,081 characters into 7,885. That's a **31x compression** in context space.

**Wire overhead:**

carrier98 trades bandwidth for context density. The display96 alphabet uses ~3 bytes UTF-8 per character, so wire size is ~1.5x larger than JSON+brotli. But the model doesn't see wire bytes - it sees characters. And those characters are 97% fewer.

| Payload | JSON + server brotli | carrier98 + server brotli | Wire Overhead |
|---------|---------------------|---------------------------|---------------|
| 1 KB | 346 bytes | 529 bytes | 1.5x |
| 10 KB | 794 bytes | 1,359 bytes | 1.7x |
| 100 KB | 6,022 bytes | 9,154 bytes | 1.5x |

**The trade-off:** Pay 1.5x bandwidth, get 31x context density.

**Why this matters:** Bandwidth is cheap. LLM inference isn't. Every character the model parses costs compute. At 100KB, carrier98 saves the model from parsing 237,196 characters of JSON syntax - all those braces, quotes, colons, and commas. That's compute you're not paying for.

**The economics:** JSON parsing on a CPU is essentially free - deterministic, fast, measured in microseconds. LLM inference is expensive - probabilistic, slow, measured in dollars per million tokens. carrier98 moves the parsing cost from expensive (model) to cheap (client CPU). Even if bandwidth is your bottleneck, you're still saving on the expensive side of the equation.

### The Format Family

| Format | Model Parses | Model Understands | Optimized For |
|--------|--------------|-------------------|---------------|
| JSON | Every token | Yes | Human readability |
| TOON | Fewer delimiters | Yes | Model readability |
| **fiche** | Minimal delimiters | Yes | Model efficiency |
| **carrier98** | Nothing | No (opaque) | Model carrying data |

**carrier98** and **fiche** are siblings:

- **carrier98** = the pipe. Opaque binary wrapped in hieroglyphs. Maximum density. The model shuttles it without parsing.
- **fiche** = the format. Model-readable structured data with Unicode delimiters. The model can parse and operate on it.

> **In practice:** When you need a model to *work with* data, use fiche. When you need a model to *move* data untouched, use carrier98. The pipe carries the format.

**[Read the full fiche specification â†’](fiche)**

---

## fiche Format (Summary)

A model-readable structured data format. Uses rare Unicode delimiters so models parse structure with minimal tokens. No escaping needed - quotes, braces, newlines are just content.

For the complete specification, examples, and design philosophy, see the **[fiche documentation](fiche)**.

### Delimiters

| Symbol | Unicode | Purpose |
|--------|---------|---------|
| `â—‰` | U+25C9 | Row start (fisheye) |
| `â”ƒ` | U+2503 | Field separator (heavy pipe) |
| `â—ˆ` | U+25C8 | Array element separator |
| `âˆ…` | U+2205 | Null value |

### Schema Declaration

```
@{root}â”ƒ{field}:{type}â”ƒ{field}:{type}...
```

**Types:** `int`, `str`, `float`, `bool`, `str[]`, `int[]`

### Example

```
@usersâ”ƒid:intâ”ƒname:strâ”ƒactive:bool
â—‰1â”ƒaliceâ”ƒtrue
â—‰2â”ƒbobâ”ƒfalse
â—‰3â”ƒcarolâ”ƒtrue
```

### With Arrays

```
@usersâ”ƒid:intâ”ƒtags:str[]
â—‰1â”ƒadminâ—ˆeditorâ—ˆsuperuser
â—‰2â”ƒviewer
```

### With Nulls

```
@recordsâ”ƒid:intâ”ƒscore:floatâ”ƒnotes:str
â—‰1â”ƒ95.5â”ƒâˆ…
â—‰2â”ƒâˆ…â”ƒpending
```

### Embedded Content (no escaping)

```
@logsâ”ƒlevel:strâ”ƒmsg:str
â—‰errorâ”ƒFailed to parse {"key": "value"}
```

Quotes, braces, colons - all just content. The `â”ƒ` delimiter is rare enough that collisions are virtually nonexistent.

### Escape Hatch

If content contains a delimiter (extremely rare), wrap in carrier98:

```
@artâ”ƒname:strâ”ƒchars:str
â—‰gradientâ”ƒğ“¹â•£â—Ÿâ•¥â—•â—â–°â—£â—¥â–Ÿğ“º
```

The hieroglyph frame signals "decode me first."

### Pipeline

```
JSON â†’ fiche (model workspace) â†’ carrier98 (transit) â†’ fiche â†’ JSON
```

The model works in fiche, the wire uses carrier98. Best of both.

---

## Limitations

1. **Root primitives**: Must be object or array (not `42` or `"hello"`)
2. **Null array elements**: Not supported (use object fields for nullable values)
3. **Single-element arrays**: Unwrap to single value
4. **Sparse arrays**: Normalized with nulls

---

## Implementations

| Language | Repository | Status |
|----------|------------|--------|
| Rust | [base-d](https://github.com/coryzibell/base-d) | Reference implementation |

---

## License

MIT OR Apache-2.0
