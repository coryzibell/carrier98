---
layout: default
title: carrier98
---

# carrier98

**Data modulation for a new era.**

carrier98 is an LLM-to-LLM wire protocol for structured data. It modulates serialized machine state into a parser-inert, copy-paste safe visual stream.

---

## Demo

**What the LLM receives:**

```
ìçπ‚îó‚óÖ‚ïó‚ñö‚ñº‚ï¶‚ïã‚óâ‚óä‚ïß‚ñö‚îè‚ïñ‚ñ¨‚îª‚ñª‚ïπ‚ï£‚ïõ‚óû‚óü‚ñ¨‚ñ¶‚ï´‚ï¨‚ñ†‚ñó‚îì‚ï°‚ó∫‚óÄ‚óî‚ïò‚óç‚î´‚óç‚ññ‚ïí‚ñ¶‚ó•‚ñ•‚ïì‚î£‚ï®‚óâ‚ï°‚ñ†‚óø‚ñß‚óé‚ñó‚îó‚óî‚ñö‚ñÆ‚ï¢‚îª‚îÉ‚ïì‚ïó‚îÅ‚ñú‚ïü‚ó∫‚ïò‚ñõ‚ñ†‚ïì‚ó§‚ï∏‚ó•‚ïß‚îÉ‚ï§‚ï∏‚ñõ‚ï°‚ñª‚ñ¶‚ïò‚ïò‚ñ¶‚óï‚ïô‚ï¢‚ïï‚óØ‚óú‚ï™‚î´‚óÄ‚ññ‚îõ‚ï¢‚ïï‚ïì‚óù‚ñ∫‚î£‚ó∫‚ñº‚ïê‚î≥‚óé‚îó‚ïï‚ó¢‚ïò‚ïü‚îÉ‚î´‚ñß‚óò‚îª‚ï™‚ï°‚ñß‚ñó‚ï†‚ñ®‚ñ§‚ñ∂‚ï´‚ñª‚ïô‚ñú‚ñà‚ñó‚îÉ‚îè‚ñò‚óû‚ñº‚ïõ‚î´‚ó§‚ñ¶‚ïê‚ó£‚óü‚óü‚ïò‚ñó‚ñõ‚ïï‚ó§‚ïù‚îÅ‚ïù‚ïª‚ï•‚ñ§‚ïî‚ï®‚ïü‚ñÆ‚ñ∞‚ïö‚ï¢‚ïû‚ï¨‚ïú‚ï®‚î≥‚îì‚î≥‚ñÆ‚îì‚óè‚óè‚ó¢‚ñ®‚ïû‚ïª‚ñò‚ï´‚óØ‚ïô‚ñß‚ïó‚ñ≤‚óø‚ï´‚ñô‚ñ†‚ï∏‚ïó‚óÖ‚ñà‚ïò‚ó∏‚ïï‚óÄ‚ïò‚óç‚óù‚óè‚ïß‚ñ†‚óÖ‚óç‚ñó‚óâ‚ñ≤‚ï∫‚ñ¨‚ñõ‚ó¢‚îó‚óØ‚ï°‚ñ∂‚ï§‚ï§‚ïù‚ïê‚ñ§‚óâ‚ñò‚ïë‚óÖ‚ñ†‚ó§‚ñª‚ï£‚ñ∞‚ïï‚ï∫‚óû‚ïë‚ïª‚îè‚îõ‚ï¢‚ñÆ‚ïπ‚îª‚ñà‚ó•‚ñ¶‚îÅ‚óπ‚ï§‚óä‚ï°‚ó¢‚ñÆ‚ï¨‚ï¢‚ïö‚óØ‚ñù‚ñú‚ó∫‚ïã‚ñ†‚ñ§‚ñò‚ñº‚ó•‚ñ∫‚óù‚îó‚ïü‚îè‚ïî‚ñà‚ï†‚óç‚ñö‚ï•‚ïì‚ñ∂‚ñ•‚ïñ‚ïï‚ñÆ‚óù‚ó£‚óÄ‚ñ∞‚ïö‚ñ©‚îÉ‚ñô‚óø‚óú‚ó¢‚ñ•‚óâ‚óÜ‚óú‚ñü‚ïê‚óÑ‚îõ‚ïì‚ó∏‚ñò‚ñº‚ó¢‚ñ¶‚ïú‚ïò‚óù‚ï•‚ïó‚îª‚óÜ‚îª‚ïì‚ï•‚óç‚ñõ‚ï™‚ñÆ‚ó£‚ñó‚óâ‚ó¢‚ïó‚ó§‚ñ∞‚ïñ‚ïã‚óÄ‚ó§‚óÜ‚ñ•‚ïí‚î´‚ïß‚ïã‚ïê‚ññ‚ï•‚ï∫‚óè‚ïê‚óù‚ñº‚ï°‚î≥‚ï∫‚îó‚óü‚ïó‚ñª‚ó∏‚ñò‚ïù‚ïã‚ï¨‚ïª‚ïß‚ï£‚ïê‚óï‚ñª‚ó£‚ñ¶‚ï©‚ï∏‚ñò‚ñÆ‚ó§‚ñ§‚ñó‚óÖ‚ó¢‚ïª‚ïû‚îª‚ï§‚ïü‚ñ•‚ñö‚ï∏‚ïí‚ñ®‚óä‚ó∫‚óè‚ñª‚ïπ‚ï°‚ñô‚ï©‚ïì‚îÅ‚óè‚ï¢‚ñ∫‚óè‚ñ≤‚óÄ‚ññ‚ñº‚ñ•‚óü‚îè‚óî‚ñ®‚ïô‚ó¢‚óî‚óº‚ïß‚óÑ‚îè‚ïñ‚óπ‚ñ®‚ñº‚ï£‚ïò‚ó£‚îõ‚ïª‚ññ‚ñô‚îõ‚ññ‚ï†‚ïó‚ïπ‚ïö‚óú‚ñ¨‚ñ≤‚ïô‚ï™‚óî‚ñ∫‚ï§‚ï´‚ïõ‚ïî‚ïû‚óï‚ïò‚óè‚ñú‚ï§‚ï†‚ó§‚ï†‚ï§‚ñ∞‚ï´‚ï†‚ïì‚î≥‚ñ†‚î≥‚î´‚ñô‚ñ©‚ñº‚ó§‚ïñ‚óø‚ï´‚óÑ‚ó§‚ó¢‚ñô‚óÄ‚ïî‚ï™‚ó∫‚ññ‚ïù‚îì‚ï•‚óÑ‚ñó‚óè‚óé‚ñ¨‚ñÆ‚îõ‚ñô‚ïô‚ñ∂‚ñ®‚ññ‚ïì‚óØ‚óé‚îõ‚ñ©‚ïî‚ñû‚ïï‚ïª‚óØ‚ïú‚î≥‚î£‚ïî‚ñ∞‚ó∫‚óÑ‚ïú‚ñÆ‚ï†‚óç‚ñ•‚ïß‚ñû‚óÜ‚îÉ‚ïî‚óÜ‚óé‚ïö‚ï¢‚óò‚óâ‚ñ•‚ïú‚ñ§‚ñà‚ñ≤‚óü‚ñ∫‚ñ∂‚ïê‚ñù‚î´‚óº‚îª‚ïô‚ïú‚ñß‚ï°‚îó‚ñ∞‚óÖ‚ñª‚óç‚ïñ‚ï†‚óπ‚ïï‚óÜ‚ñ¶‚ñò‚óú‚óØ‚îè‚ñô‚ï†‚ñ∂‚îè‚ñß‚ï°‚óÑ‚óï‚îè‚ó§‚ïù‚ñõ‚óç‚ñ∂‚óÑ‚ñ¨‚ñú‚îª‚î£‚î´‚ñû‚ñà‚óØ‚óï‚ó¢‚óÄ‚ï§‚ï†‚ó•‚ïú‚ñß‚óÑ‚ó§‚ïã‚îÉ‚ñ©‚óä‚ñû‚ñº‚ñ†‚óî‚ï∫‚ñö‚óü‚ñ∫‚óé‚ï¨‚óØ‚óû‚ñö‚ï†‚ñÆ‚îè‚î£‚ñõ‚ñ¶‚ï°‚ó§‚ñ†‚ïö‚ó§‚ñ∫‚ñô‚îì‚ñ†‚îó‚ñà‚ï§‚óú‚ï•‚ï§‚ïí‚ó•‚ñû‚ïí‚ïï‚ó£‚îè‚ï´‚ñª‚óî‚ï¢‚ñò‚óπ‚óû‚ñõ‚ïπ‚ï∫‚î≥‚ï∏‚ïñ‚ïπ‚îÅ‚óÑ‚ï™‚ïß‚îÅ‚ïü‚ñ∫‚ïõ‚ñ∞‚ñû‚ñ©‚ï∫‚ñü‚ñô‚ñº‚ñô‚ñô‚ïö‚óâ‚óº‚ïã‚îª‚óï‚ïã‚óù‚ï∏‚ïù‚ñß‚ñ•‚ï©‚óî‚î£‚ñû‚ñ§‚ñ•‚ñü‚ïπ‚ó§‚óÜ‚ïó‚ñÆ‚óÄ‚óû‚ïú‚ñ¶‚ñà‚ï©‚ï§‚ïë‚ï∏‚ïò‚ïê‚ñö‚ï´‚ïê‚ï†‚ó¢‚ñ¶‚î£‚óî‚ïï‚ïª‚ïò‚ïó‚ñû‚ñ≤‚ï¢‚óø‚ïê‚ñü‚ñß‚îè‚îè‚ñ§‚óû‚ï∫‚ñ¶‚ó§‚ñü‚ñÆ‚ñü‚îó‚ïõ‚ñ∂‚ñ∞‚ñ∞‚îó‚ï∏‚óä‚ñ©‚ñö‚ïª‚ñ¨‚ñó‚ñ∞‚ñö‚ï•‚óé‚ññ‚ïõ‚ïª‚ñü‚îõ‚ïò‚óº‚ïî‚ïª‚ñò‚ïì‚ï§‚ïü‚ïò‚óü‚ï™‚ïê‚ñú‚ñº‚ïö‚ñó‚ñô‚ñù‚ñ≤‚ï¢‚ó•‚óû‚ñò‚ñ®‚ñà‚ó§‚óÑ‚ó¢‚î´‚ñº‚ó∫‚ó§‚óï‚óº‚ó¢‚ïë‚óø‚ï®‚î£‚óç‚ñ¶‚ñ∞‚ï©‚ïí‚ñº‚óé‚ïã‚îè‚ïê‚óç‚ó•‚ñ®‚óº‚ïù‚ï§‚ï•‚ï¶‚ïñ‚ñº‚ï∏‚ïü‚óπ‚ñö‚ï®‚óÑ‚î£‚ñü‚ñ¨‚óï‚óâ‚ïù‚ï©‚ïú‚ïã‚ñ¶‚ï¨‚ï¨‚ïî‚ïô‚îó‚ïñ‚óø‚ïû‚óâ‚óç‚ñ†‚ó∫‚îÉ‚ïù‚ï¢‚ñó‚óÑ‚ïñ‚ññ‚óú‚óπ‚óÑ‚ñú‚ïï‚îì‚ñ∂‚ñß‚ñ•‚óè‚ñÆ‚ñù‚ó¢‚ñù‚ó§‚ïú‚ïü‚ñû‚ñº‚ñõ‚îÉ‚î≥‚ï°‚ñô‚óù‚ñü‚ñû‚ó¢‚óè‚ñö‚ï§‚ï∫‚ó§‚ñü‚ï∫‚óÄ‚óù‚óÖ‚ï†‚ïò‚ï´‚ïõ‚óä‚óç‚ïò‚ó£‚óò‚óé‚ñà‚î≥‚ïê‚ï®‚ï∏‚óØ‚î´‚ï°‚óû‚ñó‚ïπ‚ï©‚ï™‚ñß‚ñò‚îª‚ï¢‚ñ∞‚ïù‚ïπ‚ñö‚ïó‚ï™‚îõ‚ññ‚ï•‚óè‚ñò‚ï∏‚ó∏‚ï†‚ñà‚ñ≤‚ï§‚ïñ‚ïì‚ó•‚ñ¨‚îÅ‚ó∏‚ï•‚ïí‚ñ§‚ïü‚ñ¶‚ïì‚ïß‚ñü‚óä‚ó§‚ñ∂‚ïõ‚ï¨‚óú‚óØ‚óä‚óØ‚ñ∂‚ï¶‚óú‚î≥‚ï§‚ñò‚ïû‚ñò‚ñó‚óú‚ñ•‚îÅ‚ñû‚ï£‚ñß‚ï•‚ï∫‚ñû‚îè‚óü‚ñ∂‚óî‚ñû‚îª‚ïò‚óâ‚ñ•‚ï¶‚óé‚óò‚ï£‚ñª‚ñ∫‚óî‚ïó‚ïõ‚óº‚î≥‚î£‚ñ†‚ïì‚ó£‚ïê‚ïê‚ó£‚óù‚î≥‚ñ•‚ïß‚ñõ‚ï¶‚ñù‚ñÆ‚ó∫‚ï£‚óé‚ó¢‚ñ∫‚ïù‚îè‚ñõ‚óè‚ñ•‚ó∫‚óû‚ïí‚ï•‚ó•‚ñ†‚îõ‚óâ‚ñó‚ó§‚óø‚ñº‚ïï‚óâ‚ñú‚óî‚ñ¶‚ïù‚ïß‚óÜ‚ïò‚ïπ‚ï™‚ïí‚ïã‚ñ∞‚óè‚ïü‚ñü‚ï™‚ñô‚óï‚ï•‚ñö‚ïô‚ñº‚óØ‚ó£‚ñ®‚î£‚ïì‚î´‚ñ∂‚ñõ‚óØ‚ó§‚î´‚óú‚ñö‚ó£‚îÉ‚îÉ‚óπ‚îª‚óû‚î£‚ñ†‚ñ¶‚ñô‚ïú‚óÜ‚ï¨‚î´‚óù‚ñÆ‚ñ¶‚óù‚î≥‚ó£‚ñü‚óÄ‚ñº‚ï¢‚óø‚óÑ‚îõ‚ïí‚ïë‚ïñ‚óï‚ïê‚ñ¨‚óú‚ïú‚ï´‚ï´‚ñß‚óÖ‚ñÆ‚ó£‚ñü‚ï¨‚ñ†‚ñü‚óé‚ñó‚ïù‚î´‚ñ¨‚ñ∫‚ñú‚ñô‚îÉ‚ïù‚óû‚îÅ‚ñ¨‚óØ‚îª‚ó§‚ó¢‚ï®‚ïü‚ñú‚ïö‚ï§‚óç‚ï¶‚ïû‚ïî‚ñó‚ñû‚óä‚óò‚óï‚ñ¶‚ïï‚îè‚ïõ‚ñ¨‚îÅ‚ïù‚ïõ‚ñ∫‚óÜ‚ïô‚ó¢‚ïò‚î£‚ïò‚ó∫‚ñö‚ó¢‚ñ§‚ó£‚î≥‚îó‚ïù‚óù‚ï®‚ï´‚ïú‚î´‚ï¢‚ñà‚ïö‚î≥‚ó∫‚îÉ‚îª‚ï∫‚ïö‚ñß‚ñ≤‚ó§‚óÄ‚óû‚î´‚ïù‚ïê‚ï°‚óç‚óä‚ñù‚ï∏‚óî‚óû‚î£‚óî‚óû‚ï°‚óè‚ñû‚ï∫‚óâ‚ïª‚ñ†‚ïì‚î≥‚ñú‚óî‚ïß‚ñ¨‚óî‚ó§‚ó∏‚ï©‚ñ∞‚ï∫‚óø‚ó¢‚ó∏‚ñ§‚îè‚óú‚î≥‚ïô‚ïù‚ïªìç∫
```

**1,221 characters.** Parser-inert. Copy-paste safe.

**What the human sees** (after decode):

```json
{"quotes":[
  {"character":"Morpheus","quote":"I'm trying to free your mind, Neo. But I can only show you the door. You're the one that has to walk through it."},
  {"character":"Trinity","quote":"The answer is out there, Neo. It's looking for you, and it will find you if you want it to."},
  {"character":"Oracle","quote":"You didn't come here to make the choice. You've already made it. You're here to try to understand why you made it."},
  {"character":"Smith","quote":"Never send a human to do a machine's job."},
  {"character":"Keymaker","quote":"There is a building. Inside this building there is a level where no elevator can go, and no stair can reach."},
  ...
]}
```

**2,666 characters.** 54% larger. All those braces, quotes, and colons - syntax the LLM has to parse.

The carrier stays the same. The human gets JSON. Everyone wins.

**Jump to:** [Philosophy](#philosophy) ¬∑ [Wire Format](#wire-format) ¬∑ [Alphabet](#alphabet) ¬∑ [Binary Format](#binary-format) ¬∑ [Benchmarks](#benchmarks) ¬∑ [Implementations](#implementations)

---

## Philosophy

The carrier wave carries the signal. Like DTMF tones encoding digits for telephone switches, carrier98 encodes structured data for LLM pipelines. It's data modulation - not different from hitting 0-9 on a phone keypad, just highly advanced.

**Design principles:**

1. **Parser-inert** - No regex, JSON parser, shell, or syntax highlighter will grab it by accident
2. **Display-safe** - Renders visibly on any terminal, editor, or browser (no invisible chars, no replacement boxes)
3. **Copy-paste debuggable** - See it in a log, copy it, decode it
4. **Self-describing** - Schema embedded in the payload
5. **Dense** - Smaller than JSON, smaller than TOON

> *"The image translators work for the construct program - but there's way too much information to decode the Matrix. I don't even see the code. All I see is blonde, brunette, redhead."*

---

## The Name

**98** = 96 alphabet characters + 2 frame delimiters

Also a nod to Windows 98 - a time when machines were learning to communicate with each other.

---

## Wire Format

```
ìçπ{payload}ìç∫
```

| Component | Value | Description |
|-----------|-------|-------------|
| Frame start | `ìçπ` (U+13379) | Egyptian hieroglyph, opening quotation mark |
| Frame end | `ìç∫` (U+1337A) | Egyptian hieroglyph, closing quotation mark |
| Payload | Base-96 encoded | Binary data in carrier98 alphabet |

### Why Hieroglyphs?

These aren't arbitrary ancient characters - they're actual quotation marks from 5,000 years ago. Rope coils the Egyptians used to frame quoted text. Perfect semantic match for framing protocol data.

- **Stable**: Unicode 5.2 (2009), 15+ years proven
- **Parser-inert**: No parser on Earth looks for hieroglyphs
- **Visually distinct**: You see them, you know it's carrier98

---

## Alphabet

96 visually-safe Unicode characters:

| Range | Block | Count | Examples |
|-------|-------|-------|----------|
| U+2501‚ÄìU+257B | Box Drawing (heavy/double) | 44 | `‚îÅ` `‚îÉ` `‚îè` `‚ïî` `‚ïë` |
| U+2588‚ÄìU+259F | Block Elements | 11 | `‚ñà` `‚ñÄ` `‚ñÑ` `‚ñå` `‚ñê` |
| U+25A0‚ÄìU+25FF | Geometric Shapes (solid) | 41 | `‚ñ†` `‚ñ≤` `‚óè` `‚óÜ` `‚óâ` |

**Properties:**
- Visually distinct (no confusables like 0/O or 1/l)
- Cross-platform safe (renders on Windows, macOS, Linux)
- No blanks (nothing looks like whitespace)
- Size-independent (readable at any font size)
- Monospace-friendly (consistent width in terminals)

**Excluded:**
- ASCII (parser-visible)
- Light box drawing (invisible at small sizes)
- Outline shapes (look empty)
- Emoji (inconsistent rendering)
- CJK (width issues)
- C0/C1 control characters
- Private use areas

---

## Binary Format

```
[compression][header][values]
```

### Compression Prefix (1 byte)

| Byte | Algorithm |
|------|----------|
| 0x00 | None |
| 0x01 | Brotli |
| 0x02 | LZ4 |
| 0x03 | Zstd |

### Header

```
[flags: u8]
[root_key?: varint string]    // if FLAG_HAS_ROOT_KEY
[row_count: varint]
[field_count: varint]
[field_types: nibble-packed]
[field_names: varint strings]
[null_bitmap?: bytes]         // if FLAG_HAS_NULLS
```

**Flags:**

| Bit | Flag | Description |
|-----|------|-------------|
| 0 | TYPED_VALUES | Per-value type tags (reserved) |
| 1 | HAS_NULLS | Null bitmap present |
| 2 | HAS_ROOT_KEY | Root key in header |

**Field types (4-bit tags):**

| Tag | Type | Encoding |
|-----|------|----------|
| 0 | U64 | Varint |
| 1 | I64 | Zigzag varint |
| 2 | F64 | 8 bytes IEEE 754 |
| 3 | String | Varint length + UTF-8 |
| 4 | Bool | Packed bits |
| 5 | Null | No bytes (bitmap only) |
| 6 | Array | Varint count + elements |
| 7 | Any | Type tag + value (reserved) |

### Values

Row-major order. No delimiters between values - the schema defines boundaries.

- **Integers:** LEB128 varint (MSB continuation bit)
- **Signed integers:** Zigzag encoding, then varint
- **Floats:** 8 bytes, IEEE 754 double, little-endian
- **Strings:** Varint length + UTF-8 bytes
- **Arrays:** Varint count + elements
- **Nulls:** No bytes (tracked in bitmap)

---

## Encoding Pipeline

```
Structured Data ‚Üí IR ‚Üí Binary ‚Üí Compress ‚Üí Base96 ‚Üí Frame
```

**Intermediate Representation (IR)** is the pivot point. Parsers (JSON, YAML, CSV) produce IR. The binary packer consumes IR. This decouples input formats from the wire format.

---

## Example

**Input:**
```json
{"users":[{"id":1,"name":"alice"},{"id":2,"name":"bob"}]}
```

**Binary structure:**
```
Flags: 0x04 (HAS_ROOT_KEY)
Root key: "users"
Row count: 2
Field count: 2
Field types: [U64, String]
Field names: ["id", "name"]
Values: 1, "alice", 2, "bob"
```

**Wire format:**
```
ìçπ‚ï£‚óü‚ï•‚óï‚óù‚ñ∞‚ó£‚ó•‚ñü‚ï∫‚ññ‚óò‚ñ∞‚óù‚ñ§‚óÄ‚ïßìç∫
```

---

## Benchmarks

**What the LLM sees** (characters in context window):

| Payload | JSON | carrier98+brotli | Context Reduction |
|---------|------|------------------|-------------------|
| 1 KB | 1,055 | 403 | 62% smaller |
| 10 KB | 14,080 | 1,075 | 92% smaller |
| 100 KB | 245,081 | 7,885 | **97% smaller** |

At 100KB, you're packing 245,081 characters into 7,885. That's a **31x compression** in context space.

**Wire overhead:**

carrier98 trades bandwidth for context density. The display96 alphabet uses ~3 bytes UTF-8 per character, so wire size is ~1.5x larger than JSON+brotli. But the model doesn't see wire bytes - it sees characters. And those characters are 97% fewer.

| Payload | JSON + server brotli | carrier98 + server brotli | Wire Overhead |
|---------|---------------------|---------------------------|---------------|
| 1 KB | 346 bytes | 529 bytes | 1.5x |
| 10 KB | 794 bytes | 1,359 bytes | 1.7x |
| 100 KB | 6,022 bytes | 9,154 bytes | 1.5x |

**The trade-off:** Pay 1.5x bandwidth, get 31x context density.

**Why this matters:** Bandwidth is cheap. LLM inference isn't. Every character the model parses costs compute. At 100KB, carrier98 saves the model from parsing 237,196 characters of JSON syntax - all those braces, quotes, colons, and commas. That's compute you're not paying for.

---

## Limitations

1. **Root primitives**: Must be object or array (not `42` or `"hello"`)
2. **Null array elements**: Not supported (use object fields for nullable values)
3. **Single-element arrays**: Unwrap to single value
4. **Sparse arrays**: Normalized with nulls

---

## Implementations

| Language | Repository | Status |
|----------|------------|--------|
| Rust | [base-d](https://github.com/coryzibell/base-d) | Reference implementation |

---

## License

MIT OR Apache-2.0
